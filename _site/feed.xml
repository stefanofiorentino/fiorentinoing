<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-03T13:43:41+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Fiorentino Ing. Stefano</title><subtitle>Modern C++ · Yocto Project · Wi-Fi · BLE · Co-Founder at Italian Embedded · Organizer at C++ User Group Lugano</subtitle><entry><title type="html">I belong to a family</title><link href="http://localhost:4000/modern/cpp/2022/09/03/composition.html" rel="alternate" type="text/html" title="I belong to a family" /><published>2022-09-03T05:00:00+00:00</published><updated>2022-09-03T05:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/09/03/composition</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/09/03/composition.html">&lt;p&gt;As I am a parent, I belong to a family.&lt;/p&gt;

&lt;p&gt;So my family &lt;em&gt;has a&lt;/em&gt; family member.&lt;/p&gt;

&lt;p&gt;That’s composition.&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">As I am a parent, I belong to a family. So my family has a family member. That’s composition.</summary></entry><entry><title type="html">From switch-case to polymorphism</title><link href="http://localhost:4000/modern/cpp/2022/05/27/from_switch_case_to_polymorphism.html" rel="alternate" type="text/html" title="From switch-case to polymorphism" /><published>2022-05-27T05:00:00+00:00</published><updated>2022-05-27T05:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/05/27/from_switch_case_to_polymorphism</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/05/27/from_switch_case_to_polymorphism.html">&lt;p&gt;In the C language, neither function overload and polymorphism are present. So to be able to act polymorphically, you have to define several functions with different names (or leverage the type erasure technique).&lt;/p&gt;

&lt;p&gt;Here is a simple code that is aiming to perform a specific action given the type name (here represented as a string).&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;char* details::print_foo()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;char* details::print_bar()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// namespace details&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;perform_action_based_on_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action_to_perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action_to_perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action_to_perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_switch_case_to_polymorphism&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C_style_polymorphism&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;char* details::print_foo()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perform_action_based_on_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;char* details::print_bar()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perform_action_based_on_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the C++ language, this same code can be translated into the following:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;protected:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action_to_perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action_to_perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action_to_perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_switch_case_to_polymorphism&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cpp_style_polymorphism&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;char* details::print_foo()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;char* details::print_bar()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here the call to the action t oobe performed is easier. The factory method here acts as a type selector. Given the result of this factory method, the function call, from the callee point of view, is exaclty the same.&lt;/p&gt;

&lt;p&gt;This is the only reflection currently available in cpp, kind-of.&lt;/p&gt;

&lt;p&gt;NOTE: if the smart_ptr and the NVI pattern disturbs your understanding, just let me know.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;1) https://github.com/stefanofiorentino/experimental/blob/develop/test/from_switch_case_to_polymorphism.cpp&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">In the C language, neither function overload and polymorphism are present. So to be able to act polymorphically, you have to define several functions with different names (or leverage the type erasure technique). Here is a simple code that is aiming to perform a specific action given the type name (here represented as a string). namespace details { std::string print_foo() { return &quot;char* details::print_foo()&quot;; } std::string print_bar() { return &quot;char* details::print_bar()&quot;; } } // namespace details std::string perform_action_based_on_type(std::string const &amp;amp;action_to_perform) { if (&quot;foo&quot; == action_to_perform) { return details::print_foo(); } else if (&quot;bar&quot; == action_to_perform) { return details::print_bar(); } } TEST(from_switch_case_to_polymorphism, C_style_polymorphism) { ASSERT_EQ(&quot;char* details::print_foo()&quot;, perform_action_based_on_type(&quot;foo&quot;)); ASSERT_EQ(&quot;char* details::print_bar()&quot;, perform_action_based_on_type(&quot;bar&quot;)); } In the C++ language, this same code can be translated into the following: class base { protected: virtual std::string do_print() const = 0; public: std::string print() const { return do_print(); } }; class foo : public base { std::string do_print() const override { return details::print_foo(); } }; class bar : public base { std::string do_print() const override { return details::print_bar(); } }; std::shared_ptr&amp;lt;base&amp;gt; factory(std::string const &amp;amp;action_to_perform) { if (&quot;foo&quot; == action_to_perform) { return std::make_shared&amp;lt;foo&amp;gt;(); } else if (&quot;bar&quot; == action_to_perform) { return std::make_shared&amp;lt;bar&amp;gt;(); } } TEST(from_switch_case_to_polymorphism, Cpp_style_polymorphism) { ASSERT_EQ(&quot;char* details::print_foo()&quot;, factory(&quot;foo&quot;)-&amp;gt;print()); ASSERT_EQ(&quot;char* details::print_bar()&quot;, factory(&quot;bar&quot;)-&amp;gt;print()); } Here the call to the action t oobe performed is easier. The factory method here acts as a type selector. Given the result of this factory method, the function call, from the callee point of view, is exaclty the same. This is the only reflection currently available in cpp, kind-of. NOTE: if the smart_ptr and the NVI pattern disturbs your understanding, just let me know. Reference 1) https://github.com/stefanofiorentino/experimental/blob/develop/test/from_switch_case_to_polymorphism.cpp</summary></entry><entry><title type="html">Fold operators</title><link href="http://localhost:4000/modern/cpp/2022/04/13/fold_operators.html" rel="alternate" type="text/html" title="Fold operators" /><published>2022-04-13T05:00:00+00:00</published><updated>2022-04-13T05:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/04/13/fold_operators</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/04/13/fold_operators.html">&lt;p&gt;A good example of &lt;em&gt;fold expression&lt;/em&gt; &lt;sup&gt;[1]&lt;/sup&gt; usage is the following. In case you have a member defined as this:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Events&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;at some point, you’ll fall in need of operating on every &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handler&amp;lt;Events&amp;gt;&lt;/code&gt; instance saved in the pool. This is currently very easy to be written leveraging the fold expression as this:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is far shorter than range-loop and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::for_each&lt;/code&gt;. It costs a bit in readability, though.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;1) https://en.cppreference.com/w/cpp/language/fold&lt;/p&gt;

&lt;p&gt;2) https://github.com/stefanofiorentino/pool_type.git&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">A good example of fold expression [1] usage is the following. In case you have a member defined as this: std::tuple&amp;lt;Handler&amp;lt;Events&amp;gt;...&amp;gt; pool; at some point, you’ll fall in need of operating on every Handler&amp;lt;Events&amp;gt; instance saved in the pool. This is currently very easy to be written leveraging the fold expression as this: void clear() noexcept { std::apply([](auto &amp;amp;&amp;amp;... args) { ((args.clear()), ...); }, pool); } This is far shorter than range-loop and std::for_each. It costs a bit in readability, though. Reference 1) https://en.cppreference.com/w/cpp/language/fold 2) https://github.com/stefanofiorentino/pool_type.git</summary></entry><entry><title type="html">std::move vs std::forward</title><link href="http://localhost:4000/modern/cpp/2022/03/14/move_vs_forward.html" rel="alternate" type="text/html" title="std::move vs std::forward" /><published>2022-03-14T05:00:00+00:00</published><updated>2022-03-14T05:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/03/14/move_vs_forward</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/03/14/move_vs_forward.html">&lt;p&gt;Pass-by-value and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::move&lt;/code&gt; is suggested by clang-tidy whenever your function is just a &lt;em&gt;wrapper&lt;/em&gt;. And that’s why I used this idiom in the &lt;a href=&quot;https://github.com/stefanofiorentino/pool_type.git&quot;&gt;pool_type&lt;/a&gt; playground repository. But during the last &lt;a href=&quot;https://www.meetup.com/lugano-c-meetup/events/283927602/&quot;&gt;meetup&lt;/a&gt; came out that I can improve it, at least at some extent, by leveraging the &lt;em&gt;more generic&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::forward&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::move&lt;/code&gt;. That’s why, in the following code, both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Connection&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Listener&lt;/code&gt; are template alias:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Listener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::forward&lt;/code&gt; can be leveraged yielding the following code:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is an improvement in performance (verified by &lt;a href=&quot;https://godbolt.org/&quot;&gt;godbolt&lt;/a&gt;). But I’m not sure about the lifetime safety. I guess if someone is using this &lt;em&gt;pool_type&lt;/em&gt; template class passing to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::on&lt;/code&gt; a &lt;strong&gt;local&lt;/strong&gt; instantiation of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::function&lt;/code&gt;, it will simply segfault.&lt;/p&gt;

&lt;p&gt;I will talk with the maintainer of &lt;a href=&quot;https://github.com/skypjack/uvw&quot;&gt;uvw&lt;/a&gt; to understand if this improvement can be ported on the upstream repo too.&lt;/p&gt;

&lt;!---
NOTE: The use of `std::forward` is not necessarly yielding the universal reference idiom to be in place. Here for example, `Listener` depends on `E` (i.e., `using Listener = std::function&lt;void(E const&amp;, T &amp;)&gt;;`), so being not a complete template parameter we're still not sure compilers would gracefully accept this.
--&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;1) https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers&lt;/p&gt;

&lt;p&gt;2) (https://github.com/stefanofiorentino/pool_type.git&lt;/p&gt;

&lt;p&gt;3) https://www.meetup.com/lugano-c-meetup/events/283927602/&lt;/p&gt;

&lt;p&gt;4) https://godbolt.org/&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">Pass-by-value and std::move is suggested by clang-tidy whenever your function is just a wrapper. And that’s why I used this idiom in the pool_type playground repository. But during the last meetup came out that I can improve it, at least at some extent, by leveraging the more generic std::forward instead of std::move. That’s why, in the following code, both Connection and Listener are template alias: Connection on(Listener f) noexcept { return onL.emplace(onL.cend(), std::move(f)); } So std::forward can be leveraged yielding the following code: Connection on(Listener&amp;amp;&amp;amp; f) noexcept { return onL.emplace(onL.cend(), std::forward&amp;lt;Listener&amp;gt;(f)); } This is an improvement in performance (verified by godbolt). But I’m not sure about the lifetime safety. I guess if someone is using this pool_type template class passing to the ::on a local instantiation of a std::function, it will simply segfault. I will talk with the maintainer of uvw to understand if this improvement can be ported on the upstream repo too. Reference 1) https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers 2) (https://github.com/stefanofiorentino/pool_type.git 3) https://www.meetup.com/lugano-c-meetup/events/283927602/ 4) https://godbolt.org/</summary></entry><entry><title type="html">Custom type traits</title><link href="http://localhost:4000/modern/cpp/2022/02/17/message_type_trait.html" rel="alternate" type="text/html" title="Custom type traits" /><published>2022-02-17T05:00:00+00:00</published><updated>2022-02-17T05:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/02/17/message_type_trait</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/02/17/message_type_trait.html">&lt;h1 id=&quot;write-your-own-type-traits&quot;&gt;Write your own type traits&lt;/h1&gt;

&lt;p&gt;There is an old but fascinating way to bind feature implementation to types. This is tag dispatching and it is almost everywhere in codebases.&lt;/p&gt;

&lt;p&gt;For example if you want to manage different kind of messages under the (apparentyl) same signature, you can write your own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type_trait&lt;/code&gt; as the following:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;__Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;message_traits&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__Message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message_category&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message_category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This allows you to write the caller code in a uniform way, i.e.,&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mqtt_message_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mqtt_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mqtt_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To be able to do this, you need to define a tag type as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct mqtt_message_tag{};&lt;/code&gt; and your type to be manageable by the type_traits should declare a message category as a public type definition:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;mqtt_message_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mqtt_message_tag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message_category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt; function will look something like:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notify_dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boilerplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mqtt_message_tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// implementation details&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;__Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__Message&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message_traits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__Message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message_category&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;details&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify_dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;1) https://github.com/stefanofiorentino/message_traits/blob/master/libs/dispatcher/include/message_traits.hpp
2) https://www.fluentcpp.com/2018/04/27/tag-dispatching/&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">Write your own type traits There is an old but fascinating way to bind feature implementation to types. This is tag dispatching and it is almost everywhere in codebases. For example if you want to manage different kind of messages under the (apparentyl) same signature, you can write your own type_trait as the following: template&amp;lt;typename __Message&amp;gt; struct message_traits { typedef typename __Message::message_category message_category; }; This allows you to write the caller code in a uniform way, i.e., mqtt_message_t mqtt_message; ... notify(mqtt_message); To be able to do this, you need to define a tag type as struct mqtt_message_tag{}; and your type to be manageable by the type_traits should declare a message category as a public type definition: struct mqtt_message_t final { typedef mqtt_message_tag message_category; }; And your notify function will look something like: namespace details { inline void notify_dispatch(std::string const &amp;amp;notification, boilerplate::mqtt_message_tag) { // implementation details } } template&amp;lt;class __Message&amp;gt; void notify(__Message const &amp;amp;message) { typedef typename message_traits&amp;lt;__Message&amp;gt;::message_category category; details::notify_dispatch(message.getMessage(), category()); } Reference 1) https://github.com/stefanofiorentino/message_traits/blob/master/libs/dispatcher/include/message_traits.hpp 2) https://www.fluentcpp.com/2018/04/27/tag-dispatching/</summary></entry><entry><title type="html">Don’t wait without a condition</title><link href="http://localhost:4000/modern/cpp/2022/02/10/dont_wait_without_a_condition.html" rel="alternate" type="text/html" title="Don’t wait without a condition" /><published>2022-02-10T12:00:00+00:00</published><updated>2022-02-10T12:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/02/10/dont_wait_without_a_condition</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/02/10/dont_wait_without_a_condition.html">&lt;h1 id=&quot;dont-wait-without-a-condition&quot;&gt;Don’t wait without a condition&lt;/h1&gt;

&lt;p&gt;A wait without a condition can miss a wakeup or wake up simply to find that there is no work to do &lt;sup&gt;[1]&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;What you need to know (or remember) is that also &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::timed_mutex::try_lock_for&lt;/code&gt; &lt;em&gt;is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration&lt;/em&gt; &lt;sup&gt;[2]&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;1) https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp42-dont-wait-without-a-condition
2) https://en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_for&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">Don’t wait without a condition A wait without a condition can miss a wakeup or wake up simply to find that there is no work to do [1]. What you need to know (or remember) is that also std::timed_mutex::try_lock_for is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration [2]. Reference 1) https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp42-dont-wait-without-a-condition 2) https://en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_for</summary></entry><entry><title type="html">Erase-remove idiom</title><link href="http://localhost:4000/modern/cpp/2022/02/06/erase-remove-idiom.html" rel="alternate" type="text/html" title="Erase-remove idiom" /><published>2022-02-06T12:00:00+00:00</published><updated>2022-02-06T12:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2022/02/06/erase-remove-idiom</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2022/02/06/erase-remove-idiom.html">&lt;p&gt;If you’re are working with a C++ STL container, chances are at some point you’ll need to &lt;em&gt;delete&lt;/em&gt; some entries.
Here is the idiom you usually want to implement to both remove the entries from the collection and cancel (i.e., erase) their content (C++20 provides better solution for this).&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
...
v.erase(std::remove(v.begin(), v.end(), 5), v.end());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Did you know &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique&lt;/code&gt; has similar behaviors? That is, you need to erase the &lt;em&gt;duplicates&lt;/em&gt; by yourself.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;1) Meyers, Scott (2001). Effective STL : 50 specific ways to improve your use of the standard template library&lt;/p&gt;

&lt;p&gt;2) https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom&lt;/p&gt;

&lt;h2 id=&quot;for-the-more-formal-readers&quot;&gt;For the more formal readers:&lt;/h2&gt;

&lt;p&gt;1) https://eel.is/c++draft/alg.remove&lt;/p&gt;

&lt;p&gt;2) https://eel.is/c++draft/alg.unique&lt;/p&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html">If you’re are working with a C++ STL container, chances are at some point you’ll need to delete some entries. Here is the idiom you usually want to implement to both remove the entries from the collection and cancel (i.e., erase) their content (C++20 provides better solution for this). std::vector&amp;lt;int&amp;gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ... v.erase(std::remove(v.begin(), v.end(), 5), v.end()); Did you know std::unique has similar behaviors? That is, you need to erase the duplicates by yourself. References 1) Meyers, Scott (2001). Effective STL : 50 specific ways to improve your use of the standard template library 2) https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom For the more formal readers: 1) https://eel.is/c++draft/alg.remove 2) https://eel.is/c++draft/alg.unique</summary></entry><entry><title type="html">Json-RPC Server in C++ Moderno (02)</title><link href="http://localhost:4000/modern/cpp/2020/09/16/json-rpc-server-02.html" rel="alternate" type="text/html" title="Json-RPC Server in C++ Moderno (02)" /><published>2020-09-16T16:00:00+00:00</published><updated>2020-09-16T16:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2020/09/16/json-rpc-server-02</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2020/09/16/json-rpc-server-02.html">&lt;iframe width=&quot;736&quot; height=&quot;414&quot; src=&quot;https://www.youtube.com/embed/XUFExrXkDhQ&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html"></summary></entry><entry><title type="html">Json-RPC Server in C++ Moderno (01)</title><link href="http://localhost:4000/modern/cpp/2020/05/27/json-rpc-server-01.html" rel="alternate" type="text/html" title="Json-RPC Server in C++ Moderno (01)" /><published>2020-05-27T16:00:00+00:00</published><updated>2020-05-27T16:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2020/05/27/json-rpc-server-01</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2020/05/27/json-rpc-server-01.html">&lt;iframe width=&quot;736&quot; height=&quot;414&quot; src=&quot;https://www.youtube.com/embed/ZuSg7JM4CiE&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html"></summary></entry><entry><title type="html">Json-RPC Server in C++ Moderno (00)</title><link href="http://localhost:4000/modern/cpp/2020/05/13/json-rpc-server-00.html" rel="alternate" type="text/html" title="Json-RPC Server in C++ Moderno (00)" /><published>2020-05-13T16:00:00+00:00</published><updated>2020-05-13T16:00:00+00:00</updated><id>http://localhost:4000/modern/cpp/2020/05/13/json-rpc-server-00</id><content type="html" xml:base="http://localhost:4000/modern/cpp/2020/05/13/json-rpc-server-00.html">&lt;iframe width=&quot;736&quot; height=&quot;414&quot; src=&quot;https://www.youtube.com/embed/9EdYPxIJYoI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><category term="modern" /><category term="cpp" /><summary type="html"></summary></entry></feed>